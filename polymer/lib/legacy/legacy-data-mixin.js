import{Class}from"./class.js";import{Polymer}from"../../polymer-legacy.js";import{dedupingMixin}from"../utils/mixin.js";const UndefinedArgumentError=class extends Error{constructor(message,arg){super(message);this.arg=arg;this.name=this.constructor.name;this.constructor=UndefinedArgumentError;this.__proto__=UndefinedArgumentError.prototype}};function wrapEffect(effect,fnName){if(effect&&effect.fn){const fn=effect.fn;effect.fn=function(){try{fn.apply(this,arguments)}catch(e){if(e instanceof UndefinedArgumentError){console.warn(`Argument '${e.arg}'${fnName?` for method '${fnName}'`:""} was undefined. Ensure it has an undefined check.`)}else{throw e}}}}return effect}export const LegacyDataMixin=dedupingMixin(superClass=>{class LegacyDataMixin extends superClass{_marshalArgs(args,path,props){const vals=super._marshalArgs(args,path,props);if(this._legacyUndefinedCheck&&1<vals.length){for(let i=0;i<vals.length;i++){if(vals[i]===void 0){const name=args[i].name;throw new UndefinedArgumentError(`Argument '${name}' is undefined. Ensure it has an undefined check.`,name)}}}return vals}_addPropertyEffect(property,type,effect){return super._addPropertyEffect(property,type,wrapEffect(effect,effect&&effect.info&&effect.info.methodName))}static _addTemplatePropertyEffect(templateInfo,prop,effect){return super._addTemplatePropertyEffect(templateInfo,prop,wrapEffect(effect))}}return LegacyDataMixin});Polymer.Class=(info,mixin)=>Class(info,superClass=>mixin?mixin(LegacyDataMixin(superClass)):LegacyDataMixin(superClass));console.info("LegacyDataMixin will be applied to all legacy elements.\n"+"Set `_legacyUndefinedCheck: true` on element class to enable.");